# Поля моделей Django

Опции полей модели
[Поля модели - Опции полей](Поля%20модели%20-%20Опции%20полей.md)
<br>
[AutoField](#`AutoField`)
[BigAutoField](#`BigAutoField`)
[BigIntegerField](#`BigIntegerField`)
[BinaryField](#`BinaryField`)
[BooleanField](#`BooleanField`)
[CharField](#`CharField`)
[DateField](#`DateField`)
[DateTimeField](#`DateTimeField`)
[DecimalField](#`DecimalField`)
[DurationField](#`DurationField`)
[EmailField](#`EmailField`)
[FileField](#`FileField`)
[FloatField](#`FloatField`)
[GenericIPAddressField](#`GenericIPAddressField`)
[ImageField](#`ImageField`)
[IntegerField](#`IntegerField`)
[JSONField](#`JSONField`)
[PositiveBigIntegerField](#`PositiveBigIntegerField`)
[PositiveIntegerField](#`PositiveIntegerField`)
[PositiveSmallIntegerField](#`PositiveSmallIntegerField`)
[SlugField](#`SlugField`)
[SmallAutoField](#`SmallAutoField`)
[SmallIntegerField](#`SmallIntegerField`)
[TextField](#`TextField`)
[TimeField](#`TimeField`)
[URLField](#`URLField`)
[UUIDField](#`UUIDField`)
<br>
<br>
### `AutoField`
***
<div style='text-align:right'><small>поля модели</small></div>

`IntegerField`, который автоматически увеличивается в соответствии с доступными идентификаторами. Обычно это поле создается автоматически для поля первичного ключа. Смотрите: ref: automatic-primary-key-fields.
<br><br>
### `BigAutoField`
***
<div style='text-align:right'><small>поля модели</small></div>

64-разрядное целое число, очень похожее на `AutoField`, за исключением того, что оно гарантированно соответствует числам от `1` до `9223372036854775807`.
<br><br>
### `BigIntegerField`
***
<div style='text-align:right'><small>поля модели</small></div>

64-разрядное целое число, очень похожее на `IntegerField`, за исключением того, что оно гарантированно соответствует числам от `-9223372036854775808` до `9223372036854775807`. Виджет формы по умолчанию для этого поля [`TextInput`](https://django.fun/ru/docs/django/4.1/ref/forms/widgets/#django.forms.TextInput "django.forms.TextInput").
<br><br>
### `BinaryField`
***
<div style='text-align:right'><small>поля модели</small></div>

```python
BinaryField(
	max_length=None,
	**options
)
```
Поле для хранения необработанных двоичных данных. Может быть назначено [`bytes`](https://docs.python.org/3/library/stdtypes.html#bytes "(в Python v3.10)"), [`bytearray`](https://docs.python.org/3/library/stdtypes.html#bytearray "(в Python v3.10)") или [`memoryview`](https://docs.python.org/3/library/stdtypes.html#memoryview "(в Python v3.10)").

По умолчанию `BinaryField` устанавливает `editable` в `False`, и в этом случае он не может быть включен в `ModelForm`.

##### `max_length`
Необязательный параметр. Максимальная длина (в байтах) поля. Максимальная длина обеспечивается при проверке Django с помощью [`MaxLengthValidator`](https://django.fun/ru/docs/django/4.1/ref/validators/#django.core.validators.MaxLengthValidator "django.core.validators.MaxLengthValidator").
<br><br>
### `BooleanField`
***
<div style='text-align:right'><small>поля модели</small></div>

Поле истина/ложь.

Виджет формы по умолчанию для этого поля [`CheckboxInput`](https://django.fun/ru/docs/django/4.1/ref/forms/widgets/#django.forms.CheckboxInput "django.forms.CheckboxInput") или [`NullBooleanSelect`](https://django.fun/ru/docs/django/4.1/ref/forms/widgets/#django.forms.NullBooleanSelect "django.forms.NullBooleanSelect") если `null=True`.

Значение по умолчанию `BooleanField` равно `None`, когда `default` не определено.
<br><br>
### `CharField`
***
<div style='text-align:right'><small>поля модели</small></div>

Строковое поле, для строк малого и большого размера.

Для больших объемов текста используйте `TextField`.

Виджет формы по умолчанию для этого поля [`TextInput`](https://django.fun/ru/docs/django/4.1/ref/forms/widgets/#django.forms.TextInput "django.forms.TextInput").

CharField имеет следующие дополнительные аргументы:

#### `max_length`

>Обязательный. Максимальная длина (в символах) поля. `max_length` применяется на уровне базы данных и при проверке Django с использованием [`MaxLengthValidator`](https://django.fun/ru/docs/django/4.1/ref/validators/#django.core.validators.MaxLengthValidator "django.core.validators.MaxLengthValidator").

>Если вы пишете приложение, которое должно быть переносимо на несколько бэкэндов базы данных, вы должны знать, что для некоторых бэкэндов существуют ограничения на `max_length`. За подробностями обращайтесь к примечаниям к базе данных.

#### `db_collation`

Необязательный. Имя поля сортировки базы данных.

>Имена параметров сортировки не стандартизированы. Таким образом, это не будет переносимым между несколькими бэкэндами базы данных.

>Oracle поддерживает сопоставления, только если для параметра инициализации базы данных `MAX_STRING_SIZE` установлено значение `EXTENDED`.
<br><br>
### `DateField`
***
<div style='text-align:right'><small>поля модели</small></div>

Дата, представленная в Python экземпляром `datetime.date`. Имеет несколько дополнительных необязательных аргументов:

#### `auto_now`

Автоматически устанавливать текущую дату каждый раз, когда объект сохраняется. Полезно для отметок времени последнего изменения. Обратите внимание, что текущая дата _всегда_ используется; это не просто значение по умолчанию, которое вы можете переопределить.

Поле автоматически обновляется только при вызове `Model.save()`. Поле не обновляется при обновлении других полей другими способами, такими как `QuerySet.update()`, хотя вы можете указать пользовательское значение для поля в обновлении, как это.

#### `auto_now_add`

Автоматически установить поле на текущее время, когда объект создается впервые. Полезно для создания меток времени. Обратите внимание, что текущая дата _всегда_ используется; это не просто значение по умолчанию, которое вы можете переопределить. Так что даже если вы установите значение для этого поля при создании объекта, оно будет проигнорировано. Если вы хотите изменить это поле, установите вместо `auto_now_add=True` следующее:

-   Для [`DateField`](https://django.fun/ru/docs/django/4.1/ref/models/fields/#django.db.models.DateField "django.db.models.DateField"): `default=date.today` - от [`datetime.date.today()`](https://docs.python.org/3/library/datetime.html#datetime.date.today "(в Python v3.10)")
-   Для [`DateTimeField`](https://django.fun/ru/docs/django/4.1/ref/models/fields/#django.db.models.DateTimeField "django.db.models.DateTimeField"): `default=timezone.now` - от [`django.utils.timezone.now()`](https://django.fun/ru/docs/django/4.1/ref/utils/#django.utils.timezone.now "django.utils.timezone.now")

Виджет формы по умолчанию для этого поля [`TextInput`](https://django.fun/ru/docs/django/4.1/ref/forms/widgets/#django.forms.TextInput "django.forms.TextInput"). В админке добавляется календарь JavaScript и ярлык для «Сегодня». Включает в себя дополнительный `invalid_date` ключ сообщения об ошибке.

>Опции `auto_now_add`, `auto_now` и `default` являются взаимоисключающими. Любая комбинация этих параметров приведет к ошибке.

>Установка auto_now или auto_now_add в True приведет к тому, что в поле будут установлены editable=False и blank=True.

>Опции `auto_now` и `auto_now_add` всегда будут использовать дату в [часовом поясе по умолчанию](https://django.fun/ru/docs/django/4.1/topics/i18n/timezones/#default-current-time-zone) в момент создания или обновления. Если вам нужно что-то другое, вы можете рассмотреть возможность использования собственной функции вызываемой по умолчанию или переопределения `save()` вместо использования `auto_now` или `auto_now_add`; или используя `DateTimeField` вместо `DateField` и решая, как обрабатывать преобразование из даты-времени в дату во время отображения.
<br><br>
### `DateTimeField`
***
<div style='text-align:right'><small>поля модели</small></div>

Дата и время, представленные в Python экземпляром `datetime.datetime`. Принимает те же дополнительные аргументы, что и [`DateField`](https://django.fun/ru/docs/django/4.1/ref/models/fields/#django.db.models.DateField "django.db.models.DateField").

Виджет формы по умолчанию для этого поля это [`TextInput`](https://django.fun/ru/docs/django/4.1/ref/forms/widgets/#django.forms.TextInput "django.forms.TextInput"). Админка использует два отдельных виджета [`TextInput`](https://django.fun/ru/docs/django/4.1/ref/forms/widgets/#django.forms.TextInput "django.forms.TextInput") с ярлыками JavaScript.
<br><br>
### `DecimalField`
***
<div style='text-align:right'><small>поля модели</small></div>

Десятичное число с фиксированной точностью, представленное в Python экземпляром [`Decimal`](https://docs.python.org/3/library/decimal.html#decimal.Decimal "(в Python v3.10)"). Он проверяет ввод с помощью [`DecimalValidator`](https://django.fun/ru/docs/django/4.1/ref/validators/#django.core.validators.DecimalValidator "django.core.validators.DecimalValidator").

Имеет следующие **обязательные** аргументы:

#### `max_digits`

Максимально допустимое количество цифр в номере. Обратите внимание, что это число должно быть больше или равно `decimal_places`.

#### `decimal_places`

Количество десятичных разрядов для хранения с числом.

Например, для хранения чисел до `999.99` с разрешением 2 знака после запятой, вы используете:
```python
models.DecimalField(
	...,
	max_digits=5,
	decimal_places=2
)
```

И хранить цифры примерно до миллиарда с разрешением 10 десятичных знаков:

```python
models.DecimalField(
	...,
	max_digits=19,
	decimal_places=10
)
```

Виджетом формы по умолчанию для этого поля является [`NumberInput`](https://django.fun/ru/docs/django/4.1/ref/forms/widgets/#django.forms.NumberInput "django.forms.NumberInput"), когда [`localize`](https://django.fun/ru/docs/django/4.1/ref/forms/fields/#django.forms.Field.localize "django.forms.Field.localize") `False` или `TextInput` в противном случае.

Примечание

Для получения дополнительной информации о различиях между классами [`FloatField`](https://django.fun/ru/docs/django/4.1/ref/models/fields/#django.db.models.FloatField "django.db.models.FloatField") и [`DecimalField`](https://django.fun/ru/docs/django/4.1/ref/models/fields/#django.db.models.DecimalField "django.db.models.DecimalField"), пожалуйста, смотрите [FloatField или DecimalField](https://django.fun/ru/docs/django/4.1/ref/models/fields/#floatfield-vs-decimalfield). Вы также должны ознакомиться с [ограничения SQLite](https://django.fun/ru/docs/django/4.1/ref/databases/#sqlite-decimal-handling) для десятичных полей.
<br><br>
### `DurationField`
***
<div style='text-align:right'><small>поля модели</small></div>

Поле для хранения периодов времени - смоделировано в Python с помощью `timedelta`. При использовании в PostgreSQL используемый тип данных представляет собой `interval`, а в Oracle тип данных представляет собой `INTERVAL DAY (9) TO SECOND (6)`. В противном случае используется `bigint` микросекунд.

>Арифметика с `DurationField` работает в большинстве случаев. Однако во всех базах данных, кроме PostgreSQL, сравнение значения `DurationField` с арифметикой в экземплярах `DateTimeField` не будет работать должным образом.
<br><br>
### `EmailField`
***
<div style='text-align:right'><small>поля модели</small></div>

Класс `CharField`, который проверяет, является ли значение действительным адресом электронной почты, используя [`EmailValidator`](https://django.fun/ru/docs/django/4.1/ref/validators/#django.core.validators.EmailValidator "django.core.validators.EmailValidator").
<br><br>
### `FileField`
***
<div style='text-align:right'><small>поля модели</small></div>
Поле для загрузки файла.

>Аргумент `primary_key` не поддерживается и выдает ошибку, если используется.

Имеет следующие необязательные аргументы:

#### `upload_to`

Этот атрибут обеспечивает способ указания каталога загрузки и имени файла и может быть установлен двумя способами. В обоих случаях значение передается методу [`Storage.save()`](https://django.fun/ru/docs/django/4.1/ref/files/storage/#django.core.files.storage.Storage.save "django.core.files.storage.Storage.save").

1. Если указать строковое значение или [`Path`](https://docs.python.org/3/library/pathlib.html#pathlib.Path "(в Python v3.10)"), оно может содержать форматирование [`strftime()`](https://docs.python.org/3/library/time.html#time.strftime "(в Python v3.10)"), которое будет заменено датой/временем загрузки файла (чтобы загруженные файлы не заполняли заданный каталог). Например:

```python
class MyModel(models.Model):
    # file will be uploaded to MEDIA_ROOT/uploads
    upload = models.FileField(upload_to='uploads/')
    # or...
    # file will be saved to MEDIA_ROOT/uploads/2015/01/30
    upload = models.FileField(upload_to='uploads/%Y/%m/%d/')
```

Если вы используете по умолчанию [`FileSystemStorage`](https://django.fun/ru/docs/django/4.1/ref/files/storage/#django.core.files.storage.FileSystemStorage "django.core.files.storage.FileSystemStorage"), строковое значение будет добавлено к вашему пути [`MEDIA_ROOT`](https://django.fun/ru/docs/django/4.1/ref/settings/#std-setting-MEDIA_ROOT), чтобы сформировать местоположение в локальной файловой системе, где будут находиться загруженные файлы. Если вы используете другое хранилище, проверьте документацию этого хранилища, чтобы увидеть, как оно обрабатывает `upload_to`.

2. `upload_to` также может быть вызываемым объектом, например, функцией. Он будет вызван для получения пути загрузки, включая имя файла. Этот вызываемый объект должен принимать два аргумента и возвращать путь в стиле Unix (с косой чертой) для передачи в систему хранения. Два аргумента:

- `instance`

	Экземпляр модели, где определено `FileField`. Более конкретно, это случай, когда текущий файл присоединяется.

	В большинстве случаев этот объект еще не был сохранен в базе данных, поэтому, если он использует значение по умолчанию `AutoField`, он может еще не иметь значения для своего поля первичного ключа.

- `filename`

	Имя файла, которое изначально было указано в файле. Это может или не может быть принято во внимание при определении окончательного пути назначения.

Например:

```python
def user_directory_path(instance, filename):
    # file will be uploaded to MEDIA_ROOT/user_<id>/<filename>
    return 'user_{0}/{1}'.format(instance.user.id, filename)

class MyModel(models.Model):
    upload = models.FileField(upload_to=user_directory_path)
```
<br>
#### `storage`

Объект хранения или вызываемый объект, который возвращает объект хранения. Обрабатывает хранение и поиск ваших файлов. Смотрите [Управление файлами](https://django.fun/ru/docs/django/4.1/topics/files/) для получения подробной информации о том, как предоставить этот объект.

Виджетом формы по умолчанию для этого поля является [`ClearableFileInput`](https://django.fun/ru/docs/django/4.1/ref/forms/widgets/#django.forms.ClearableFileInput "django.forms.ClearableFileInput").

Использование `FileField` или `ImageField` (см. ниже) в модели требует нескольких шагов:

1.  В вашем файле настроек вам нужно определить `MEDIA_ROOT` как полный путь к директории, в которой вы хотите, чтобы Django хранил загруженные файлы. (Для повышения производительности эти файлы не хранятся в базе данных). Определите `MEDIA_URL` как базовый публичный URL этого каталога. Убедитесь, что этот каталог доступен для записи учетной записи пользователя веб-сервера.
2.  Добавьте `FileField` или `ImageField` к вашей модели, определив параметр `upload_to`, чтобы указать подкаталог `MEDIA_ROOT`, который будет использоваться для загружаемых файлов.
3.  Все, что будет храниться в вашей базе данных, это путь к файлу (относительно `MEDIA_ROOT`). Вы, скорее всего, захотите использовать [`url`](https://django.fun/ru/docs/django/4.1/ref/models/fields/#django.db.models.fields.files.FieldFile.url "django.db.models.fields.files.FieldFile.url"), предоставленный Django. Например, если ваш `ImageField` называется `mug_shot`, вы можете получить абсолютный путь к вашему изображению в шаблоне с помощью `{{ object.mug_shot.url }}`.

Например, скажем, что ваш параметр `MEDIA_ROOT` установлен в `'/home/media'`, а для `upload_to` установлен `'photos/%Y/%m/%d'`. Часть `'%Y/%m/%d'` в `upload_to` имеет форматирование [`strftime()`](https://docs.python.org/3/library/time.html#time.strftime "(в Python v3.10)"); `'%Y'` - четырехзначный год, `'%m'` - двузначный месяц, а `'% d'` - двузначный день. Если вы загрузите файл 15 января 2007 года, он будет сохранен в каталоге `/home/media/photos/2007/01/15`.

Если вы хотите получить имя файла загруженного файла на диске или размер файла, вы можете использовать атрибуты [`name`](https://django.fun/ru/docs/django/4.1/ref/files/file/#django.core.files.File.name "django.core.files.File.name") и [`File`](https://django.fun/ru/docs/django/4.1/ref/files/file/#django.core.files.File "django.core.files.File") соответственно; для получения дополнительной информации о доступных атрибутах и методах см. [`File`](https://django.fun/ru/docs/django/4.1/ref/files/file/#django.core.files.File "django.core.files.File") и руководство по темам [Управление файлами](https://django.fun/ru/docs/django/4.1/topics/files/).

>Файл сохраняется как часть сохранения модели в базе данных, поэтому фактическое имя файла, используемое на диске, не может быть определено до тех пор, пока модель не будет сохранена.

Относительный URL загруженного файла можно получить с помощью атрибута [`url`](https://django.fun/ru/docs/django/4.1/ref/models/fields/#django.db.models.fields.files.FieldFile.url "django.db.models.fields.files.FieldFile.url"). Внутренне это вызывает метод [`url()`](https://django.fun/ru/docs/django/4.1/ref/files/storage/#django.core.files.storage.Storage.url "django.core.files.storage.Storage.url") базового класса [`Storage`](https://django.fun/ru/docs/django/4.1/ref/files/storage/#django.core.files.storage.Storage "django.core.files.storage.Storage").

Обратите внимание, что при работе с загруженными файлами следует внимательно следить за тем, куда вы их загружаете и какого они типа, чтобы избежать дыр в безопасности. _Проверяйте все загружаемые файлы_, чтобы быть уверенным, что файлы являются тем, чем вы их считаете. Например, если вы вслепую позволите кому-то загружать файлы без проверки в каталог, который находится в корне документа вашего веб-сервера, то кто-то может загрузить CGI или PHP-скрипт и выполнить его, посетив URL вашего сайта. Не позволяйте этого.

Также обратите внимание, что даже загруженный файл HTML, поскольку он может выполняться браузером (но не сервером), может создавать угрозы безопасности, эквивалентные атакам XSS или CSRF.

Экземпляры `FileField` создаются в вашей базе данных как `varchar` столбцы с максимальной длиной по умолчанию 100 символов. Как и в других полях, вы можете изменить максимальную длину, используя аргумент `max_length`.
<br><br>
#### `FieldFile`


Когда вы обращаетесь к [`FileField`](#`FileField`) в модели, вам предоставляется экземпляр `FieldFile` в качестве прокси для доступа к базовому файлу.

API класса `FieldFile` отражает интерфейс класса [`File`](https://django.fun/ru/docs/django/4.1/ref/files/file/#django.core.files.File "django.core.files.File"), с одним ключевым отличием: _Объект, обернутый классом, не обязательно является оберткой вокруг встроенного в Python файлового объекта._ Вместо этого он является оберткой вокруг результата метода [`Storage.open()`](https://django.fun/ru/docs/django/4.1/ref/files/storage/#django.core.files.storage.Storage.open "django.core.files.storage.Storage.open"), который может быть [`File`](https://django.fun/ru/docs/django/4.1/ref/files/file/#django.core.files.File "django.core.files.File"), или это может быть реализация пользовательского хранилища API [`File`](https://django.fun/ru/docs/django/4.1/ref/files/file/#django.core.files.File "django.core.files.File").

В дополнение к API, унаследованному от [`File`](https://django.fun/ru/docs/django/4.1/ref/files/file/#django.core.files.File "django.core.files.File"), такого как `read()` и `write()`, `FieldFile` включает в себя несколько методов, которые могут использоваться для взаимодействия с базовым файлом:

>Два метода этого класса [`save()`](https://django.fun/ru/docs/django/4.1/ref/models/fields/#django.db.models.fields.files.FieldFile.save "django.db.models.fields.files.FieldFile.save") и [`delete()`](https://django.fun/ru/docs/django/4.1/ref/models/fields/#django.db.models.fields.files.FieldFile.delete "django.db.models.fields.files.FieldFile.delete"), по умолчанию сохраняют объект модели связанного `FieldFile` в базе данных.

#### `FieldFile.name`

Имя файла, включая относительный путь от корня [`Storage`](https://django.fun/ru/docs/django/4.1/ref/files/storage/#django.core.files.storage.Storage "django.core.files.storage.Storage") связанного [`FileField`](https://django.fun/ru/docs/django/4.1/ref/models/fields/#django.db.models.FileField "django.db.models.FileField").

#### `FieldFile.path`

Доступное только для чтения свойство для доступа к пути файла в локальной файловой системе путем вызова метода [`path()`](https://django.fun/ru/docs/django/4.1/ref/files/storage/#django.core.files.storage.Storage.path "django.core.files.storage.Storage.path") базового класса [`Storage`](https://django.fun/ru/docs/django/4.1/ref/files/storage/#django.core.files.storage.Storage "django.core.files.storage.Storage").

#### `FieldFile.size`

Результат базового метода [`Storage.size()`](https://django.fun/ru/docs/django/4.1/ref/files/storage/#django.core.files.storage.Storage.size "django.core.files.storage.Storage.size").

#### `FieldFile.url`

Доступное только для чтения свойство для доступа к относительному URL-адресу файла путем вызова метода [`url()`](https://django.fun/ru/docs/django/4.1/ref/files/storage/#django.core.files.storage.Storage.url "django.core.files.storage.Storage.url") базового класса [`Storage`](https://django.fun/ru/docs/django/4.1/ref/files/storage/#django.core.files.storage.Storage "django.core.files.storage.Storage").

#### `FieldFile.open`(_mode='rb'_)

Открывает или повторно открывает файл, связанный с этим экземпляром, в указанном режиме `mode`. В отличие от стандартного метода `open()` Python, он не возвращает файловый дескриптор.

Поскольку базовый файл открывается неявно при доступе к нему, может не быть нужным вызывать этот метод, кроме как для сброса указателя на базовый файл или для изменения `mode`.

#### `FieldFile.close`()

Ведет себя как стандартный метод `file.close()` Python и закрывает файл, связанный с этим экземпляром.

#### `FieldFile.save`(_name_, _content_, _save=True_)

Этот метод берет имя файла и содержимое файла и передает их в класс хранения для поля, а затем связывает сохраненный файл с полем модели. Если вы хотите вручную связать данные файла с экземплярами [`FileField`](https://django.fun/ru/docs/django/4.1/ref/models/fields/#django.db.models.FileField "django.db.models.FileField") в вашей модели, метод `save()` используется для сохранения этих данных файла.

Принимает два обязательных аргумента: `name`, который является именем файла, и `content`, который является объектом, содержащим содержимое файла. Необязательный аргумент `save` управляет сохранением экземпляра модели после изменения файла, связанного с этим полем. По умолчанию `True`.

Обратите внимание, что аргумент `content` должен быть экземпляром [`django.core.files.File`](https://django.fun/ru/docs/django/4.1/ref/files/file/#django.core.files.File "django.core.files.File"), а не встроенным файловым объектом Python. Вы можете создать [`File`](https://django.fun/ru/docs/django/4.1/ref/files/file/#django.core.files.File "django.core.files.File") из существующего объекта файла Python, например:

```python
from django.core.files import File
# Open an existing file using Python's built-in open()
f = open('/path/to/hello.world')
myfile = File(f)`
```

Или вы можете построить один из строки Python, как здесь:

```python
from django.core.files.base import ContentFile
myfile = ContentFile("hello world")
```

Для получения дополнительной информации смотрите [Управление файлами](https://django.fun/ru/docs/django/4.1/topics/files/).

#### `FieldFile.delete`(_save=True_)

Удаляет файл, связанный с этим экземпляром, и очищает все атрибуты в поле. Примечание. Этот метод закрывает файл, если он открывается при вызове `delete()`.

Необязательный аргумент `save` определяет, будет ли экземпляр модели сохранен после удаления файла, связанного с этим полем. По умолчанию `True`.

Обратите внимание, что при удалении модели связанные файлы не удаляются. Если вам нужно очистить потерянные файлы, вам придется обрабатывать их самостоятельно (например, с помощью настраиваемой команды управления, которую можно запускать вручную или запускать по расписанию, например, через cron).
<br><br>
### `FilePathField`
***
<div style='text-align:right'><small>поля модели</small></div>

```python
FilePathField(
	path='',
	match=None,
	recursive=False,
	allow_files=True,
	allow_folders=False,
	max_length=100,
	**options
)
```

`CharField`, выбор которого ограничен именами файлов в определенном каталоге файловой системы. Имеет три специальных аргумента, первый из которых **обязателен**:
<br>
#### `path`

Обязательный. Абсолютный путь файловой системы к каталогу, из которого `FilePathField` должен получить свой выбор. Пример: `"/home/images"`.

`path` также может вызываться, например, функция для динамического задания пути во время выполнения. Пример:

```python
import os
from django.conf import settings
from django.db import models

def images_path():
    return os.path.join(settings.LOCAL_FILE_DIR, 'images')

class MyModel(models.Model):
    file = models.FilePathField(path=images_path)
```
<br>
#### `match`

Не обязательный. Регулярное выражение в виде строки, которое `FilePathField` будет использовать для фильтрации имен файлов. Обратите внимание, что регулярное выражение будет применяться к базовому имени файла, а не к полному пути. Пример: `"foo.*\.txt$"`, который будет соответствовать файлу с именем `foo23.txt`, но не `bar.txt` или `foo23.png`.

Одна потенциальная ошибка заключается в том, что [`match`](https://django.fun/ru/docs/django/4.1/ref/models/fields/#django.db.models.FilePathField.match "django.db.models.FilePathField.match") применяется к базовому имени файла, а не к полному пути. Итак, этот пример
```python
FilePathField(path="/home/images", match="foo.*", recursive=True)
```
…будет соответствовать `/home/images/foo.png`, но не `/home/images/foo/bar.png`, потому что [`match`](https://django.fun/ru/docs/django/4.1/ref/models/fields/#django.db.models.FilePathField.match "django.db.models.FilePathField.match") применяется к базовому имени файла (`foo.png` и `bar.png`).
<br>
#### `recursive`

Не обязательный. Либо `True` либо `False`. По умолчанию установлено значение `False`. Указывает, должны ли быть включены все подкаталоги `path`
<br>
#### `allow_files`

Не обязательный. Либо `True`, либо `False`. По умолчанию установлено значение `True`. Указывает, следует ли включать файлы в указанном месте. Либо это, либо `allow_folders` должно быть `True`.

#### `allow_folders`

Не обязательнгый. Либо `True`, либо `False`. По умолчанию установлено значение `False`. Указывает, следует ли включать папки в указанном месте. Либо это, либо `allow_files` должно быть `True`.


>class: FilePathField экземпляры создаются в вашей базе данных как` varchar` столбцы с максимальной длиной по умолчанию 100 символов. Как и в других полях, вы можете изменить максимальную длину, используя аргумент: attr: ~ CharField.max_length.

<br><br>
### `FloatField`
***
<div style='text-align:right'><small>поля модели</small></div>

Число с плавающей точкой, представленное в Python экземпляром `float`.

Виджетом формы по умолчанию для этого поля является [`NumberInput`](https://django.fun/ru/docs/django/4.1/ref/forms/widgets/#django.forms.NumberInput "django.forms.NumberInput"), когда [`localize`](https://django.fun/ru/docs/django/4.1/ref/forms/fields/#django.forms.Field.localize "django.forms.Field.localize") `False` или `TextInput` в противном случае.

`FloatField` против `DecimalField`

Класс `FloatField` иногда сопоставляют с классом `DecimalField`. Хотя они оба представляют действительные числа, они представляют эти числа по-разному. `FloatField` использует внутри Python тип `float`, а `DecimalField` использует тип `Decimal`. Информацию о разнице между ними смотрите в документации Python для модуля [`decimal`](https://docs.python.org/3/library/decimal.html#module-decimal "(в Python v3.10)").
<br><br>
### `GenericIPAddressField`
***
<div style='text-align:right'><small>поля модели</small></div>

```python
GenericIPAddressField(
	protocol='both',
	unpack_ipv4=False,
	**options
)
```

Адрес IPv4 или IPv6 в строковом формате (например, `192.0.2.30` или `2a02:42fe::4`). Виджет формы по умолчанию для этого поля [`TextInput`](https://django.fun/ru/docs/django/4.1/ref/forms/widgets/#django.forms.TextInput "django.forms.TextInput").

Нормализация адресов IPv6 следует [**RFC 4291#section-2.2**](https://datatracker.ietf.org/doc/html/rfc4291.html#section-2.2) разделу 2.2, включая использование формата IPv4, предложенного в параграфе 3 этого раздела, как `::ffff:192.0.2.0`. Например, `2001:0::0:01` будет нормализован до `2001::1`, а `::ffff:0a0a:0a0a` до `::ffff:10.10.10.10`. Все символы преобразуются в строчные.
<br>
#### `protocol`

Ограничивает допустимый ввод для указанного протокола. Допустимые значения: `'both'` (по умолчанию), `'IPv4'` или `'IPv6'`. Соответствие регистронезависимо.
<br>
#### `unpack_ipv4`

Распаковывает сопоставленные адреса IPv4 как `::ffff:192.0.2.1`. Если опция включена, то адрес будет распакован в `192.0.2.1`. По умолчанию отключена. Может использоваться только в том случае, если `protocol` установлено в `'both'`.

Если вы разрешаете пустые значения, вы должны разрешить нулевые значения, так как пустые значения сохраняются как нулевые.
<br><br>
### `ImageField`
***
<div style='text-align:right'><small>поля модели</small></div>

```python
ImageField(
	upload_to=None,
	height_field=None,
	width_field=None,
	max_length=100,
	**options
)
```

Наследует все атрибуты и методы из `FileField`, но также проверяет, что загруженный объект является допустимым изображением.

В дополнение к специальным атрибутам, которые доступны для `FileField`, `ImageField` также имеет атрибуты `height` и `width`.

Чтобы облегчить запрос по этим атрибутам, `ImageField` имеет следующие необязательные аргументы:
<br>
#### `height_field`

Имя поля модели, которое будет автоматически заполняться высотой изображения при каждом сохранении экземпляра модели.
<br>
#### `width_field`

Имя поля модели, которое будет автоматически заполняться шириной изображения при каждом сохранении экземпляра модели.

>Требуется библиотека [Pillow](https://pillow.readthedocs.io/en/latest/).

>Экземпляры `ImageField` создаются в вашей базе данных как `varchar` столбцы с максимальной длиной по умолчанию 100 символов. Как и в других полях, вы можете изменить максимальную длину, используя аргумент `max_length`.

>Виджетом формы по умолчанию для этого поля является [`ClearableFileInput`](https://django.fun/ru/docs/django/4.1/ref/forms/widgets/#django.forms.ClearableFileInput "django.forms.ClearableFileInput").
<br><br>
### `IntegerField`
***
<div style='text-align:right'><small>поля модели</small></div>

Целое число. Значения от `-2147483648` до `2147483647` безопасны во всех базах данных, поддерживаемых Django.

Он использует [`MinValueValidator`](https://django.fun/ru/docs/django/4.1/ref/validators/#django.core.validators.MinValueValidator "django.core.validators.MinValueValidator") и [`MaxValueValidator`](https://django.fun/ru/docs/django/4.1/ref/validators/#django.core.validators.MaxValueValidator "django.core.validators.MaxValueValidator") для проверки ввода на основе значений, которые поддерживает база данных по умолчанию.

Виджетом формы по умолчанию для этого поля является [`NumberInput`](https://django.fun/ru/docs/django/4.1/ref/forms/widgets/#django.forms.NumberInput "django.forms.NumberInput"), когда [`localize`](https://django.fun/ru/docs/django/4.1/ref/forms/fields/#django.forms.Field.localize "django.forms.Field.localize") `False` или `TextInput` в противном случае.
<br><br>
### `JSONField`
***
<div style='text-align:right'><small>поля модели</small></div>

```python
JSONField(
	encoder=None,
	decoder=None,
	**options
)
```

Поле для хранения данных в кодировке JSON. В Python данные представляются в родном для Python формате: словари, списки, строки, числа, булевы и `None`.

`JSONField` поддерживается на MariaDB, MySQL 5.7.8+, Oracle, PostgreSQL и SQLite (с [JSON1 extension enabled](https://django.fun/ru/docs/django/4.1/ref/databases/#sqlite-json1)).
<br>
#### `encoder`

Необязательный подкласс [`json.JSONEncoder`](https://docs.python.org/3/library/json.html#json.JSONEncoder "(в Python v3.10)") для сериализации типов данных, не поддерживаемых стандартным сериализатором JSON (например, `datetime.datetime` или [`UUID`](https://docs.python.org/3/library/uuid.html#uuid.UUID "(в Python v3.10)")). Например, вы можете использовать класс [`DjangoJSONEncoder`](https://django.fun/ru/docs/django/4.1/topics/serialization/#django.core.serializers.json.DjangoJSONEncoder "django.core.serializers.json.DjangoJSONEncoder").

По умолчанию используется `json.JSONEncoder`.
<br>
#### `decoder`

Необязательный подкласс [`json.JSONDecoder`](https://docs.python.org/3/library/json.html#json.JSONDecoder "(в Python v3.10)") для десериализации значения, полученного из базы данных. Значение будет в формате, выбранном пользовательским кодировщиком (чаще всего это строка). Ваша десериализация, возможно, должна учитывать тот факт, что вы не можете быть уверены в типе ввода. Например, вы рискуете вернуть `datetime`, который на самом деле был строкой в том же формате, который выбран для `datetime`.

По умолчанию используется `json.JSONDencoder`.

>Если вы задаете для поля `default`, убедитесь, что это неизменяемый объект, такой как `str`, или вызываемый объект, который каждый раз возвращает свежий изменяемый объект, такие как `dict` или функция. Предоставление изменяемого объекта по умолчанию, такого как `default={}` или `default=[]`, разделяет один объект между всеми экземплярами модели.

Чтобы запросить `JSONField` в базе данных, смотрите [Запросы к JSONField](https://django.fun/ru/docs/django/4.1/topics/db/queries/#querying-jsonfield).

>`Index` и `Field.db_index` оба создают индекс B-Tree, который не особенно полезен при запросах к `JSONField`. Только в PostgreSQL вы можете использовать [`GinIndex`](https://django.fun/ru/docs/django/4.1/ref/contrib/postgres/indexes/#django.contrib.postgres.indexes.GinIndex "django.contrib.postgres.indexes.GinIndex"), который лучше подходит.

>PostgreSQL имеет два собственных типа данных на основе JSON: `json` и `jsonb`. Основное различие между ними заключается в том, как они хранятся и как к ним можно обращаться. Поле `json` в PostgreSQL хранится как оригинальное строковое представление JSON и должно быть декодировано на лету при запросе на основе ключей. Поле `jsonb` хранится на основе фактической структуры JSON, что позволяет осуществлять индексирование. Компромиссом является небольшая дополнительная стоимость записи в поле `jsonb`. В `JSONField` используется `jsonb`.

>База данных Oracle не поддерживает хранение скалярных значений JSON. Поддерживаются только объекты и массивы JSON (представленные в Python с использованием [`dict`](https://docs.python.org/3/library/stdtypes.html#dict "(в Python v3.10)") и [`list`](https://docs.python.org/3/library/stdtypes.html#list "(в Python v3.10)")).
<br><br>
### `PositiveBigIntegerField`
***
<div style='text-align:right'><small>поля модели</small></div>

Как a: class: PositiveIntegerField, но допускает значения только в определенной (зависящей от базы данных) точке. Значения от `` 0`` до `` 9223372036854775807`` безопасны во всех базах данных, поддерживаемых Django.
<br><br>
### `PositiveIntegerField`
***
<div style='text-align:right'><small>поля модели</small></div>

Подобно [`IntegerField`](https://django.fun/ru/docs/django/4.1/ref/models/fields/#django.db.models.IntegerField "django.db.models.IntegerField"), но должно быть либо положительным, либо нулевым (`0`). Значения от `0` до `2147483647` безопасны во всех базах данных, поддерживаемых Django. Значение `0` принимается по причинам обратной совместимости.
<br><br>
### `PositiveSmallIntegerField`
***
<div style='text-align:right'><small>поля модели</small></div>

Как и [`PositiveIntegerField`](https://django.fun/ru/docs/django/4.1/ref/models/fields/#django.db.models.PositiveIntegerField "django.db.models.PositiveIntegerField"), но допускает значения только в определенной (зависящей от базы данных) точке. Значения от `0` до `32767` безопасны во всех базах данных, поддерживаемых Django.
<br><br>
### `SlugField`
***
<div style='text-align:right'><small>поля модели</small></div>

```python
SlugField(
	max_length=50,
	**options
)
```
[Slug](https://django.fun/ru/docs/django/4.1/glossary/#term-slug) - газетный термин. Слаг - это короткая метка для чего-либо, содержащая только буквы, цифры, подчеркивания или дефисы. Они обычно используются в URL.

Как и в случае CharField, вы можете указать [`max_length`](https://django.fun/ru/docs/django/4.1/ref/models/fields/#django.db.models.CharField.max_length "django.db.models.CharField.max_length") (читайте заметку о переносимости базы данных и [`max_length`](https://django.fun/ru/docs/django/4.1/ref/models/fields/#django.db.models.CharField.max_length "django.db.models.CharField.max_length") в этом разделе). Если [`max_length`](https://django.fun/ru/docs/django/4.1/ref/models/fields/#django.db.models.CharField.max_length "django.db.models.CharField.max_length") не указан, Django будет использовать длину по умолчанию 50.

Подразумевает установку `Field.db_index` в `True`.

Часто полезно автоматически предварительно заполнить поле SlugField на основе значения некоторого другого значения. Вы можете сделать это автоматически в админке, используя [`prepopulated_fields`](https://django.fun/ru/docs/django/4.1/ref/contrib/admin/#django.contrib.admin.ModelAdmin.prepopulated_fields "django.contrib.admin.ModelAdmin.prepopulated_fields").

Он использует [`validate_slug`](https://django.fun/ru/docs/django/4.1/ref/validators/#django.core.validators.validate_slug "django.core.validators.validate_slug") или [`validate_unicode_slug`](https://django.fun/ru/docs/django/4.1/ref/validators/#django.core.validators.validate_unicode_slug "django.core.validators.validate_unicode_slug") для проверки.

#### `allow_unicode`

Если `True`, поле принимает символы Unicode в дополнение к символам ASCII. По умолчанию `False`.
<br><br>
### `SmallAutoField`
***
<div style='text-align:right'><small>поля модели</small></div>

Подобно `AutoField`, но допускает только значения в определенном (зависящим от базы данных) диапазоном. Значения от `1` до `32767` безопасны во всех базах данных, поддерживаемых Django.
<br><br>
### `SmallIntegerField`
***
<div style='text-align:right'><small>поля модели</small></div>

Подобно `IntegerField`, но допускает значения только в определенной (зависящей от базы данных) точке. Значения от `-32768` до `32767` безопасны во всех базах данных, поддерживаемых Django.
<br><br>
### `TextField`
***
<div style='text-align:right'><small>поля модели</small></div>

Большое текстовое поле. Виджет формы по умолчанию для этого поля [`Textarea`](https://django.fun/ru/docs/django/4.1/ref/forms/widgets/#django.forms.Textarea "django.forms.Textarea").

Если вы укажете атрибут `max_length`, он будет отражен в виджете `Textarea` автоматически сгенерированного поля формы. Однако это не применяется на уровне модели или базы данных. Для этого используйте `CharField`.

#### `db_collation`

Необязательный. Имя поля сортировки базы данных.

>Имена параметров сортировки не стандартизированы. Таким образом, это не будет переносимым между несколькими бэкэндами базы данных.

>Oracle не поддерживает параметры сортировки для TextField.

<br><br>
### `TimeField`
***
<div style='text-align:right'><small>поля модели</small></div>

```python
TimeField(
	auto_now=False,
	auto_now_add=False,
	**options
)
```

Время, представленное в Python экземпляром `datetime.time`. Принимает те же параметры автоматического заполнения, что и `DateField`.

Виджет формы по умолчанию для этого поля [`TextInput`](https://django.fun/ru/docs/django/4.1/ref/forms/widgets/#django.forms.TextInput "django.forms.TextInput"). В админке добавляется несколько скриптов JavaScript.
<br><br>
### `URLField`
***
<div style='text-align:right'><small>поля модели</small></div>

```python
URLField(
	max_length=200,
	**options
)
```

`CharField` для URL, проверяется валидатором [`URLValidator`](https://django.fun/ru/docs/django/4.1/ref/validators/#django.core.validators.URLValidator "django.core.validators.URLValidator").

Виджет формы по умолчанию для этого поля [`TextInput`](https://django.fun/ru/docs/django/4.1/ref/forms/widgets/#django.forms.TextInput "django.forms.TextInput").

Как и все подклассы `CharField`, `URLField` принимает необязательный аргумент `max_length`. Если вы не укажете `max_length`, используется значение по умолчанию 200.
<br><br>
### `UUIDField`
***
<div style='text-align:right'><small>поля модели</small></div>

Поле для хранения универсально уникальных идентификаторов. Использует класс Python [`UUID`](https://docs.python.org/3/library/uuid.html#uuid.UUID "(в Python v3.10)"). При использовании в PostgreSQL сохраняется в типе данных `uuid`, иначе в `char(32)`.

Универсально уникальные идентификаторы являются хорошей альтернативой `AutoField` для `primary_key`. База данных не будет генерировать UUID для вас, поэтому рекомендуется использовать `default`:

```python
import uuid
from django.db import models

class MyUUIDModel(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    # other fields
```
Обратите внимание, что вызываемый (без круглых скобок) передается в `default`, а не в экземпляр `UUID`.

>Использование [`iexact`](https://django.fun/ru/docs/django/4.1/ref/models/querysets/#std-fieldlookup-iexact), [`contains`](https://django.fun/ru/docs/django/4.1/ref/models/querysets/#std-fieldlookup-contains), [`icontains`](https://django.fun/ru/docs/django/4.1/ref/models/querysets/#std-fieldlookup-icontains), [`startswith`](https://django.fun/ru/docs/django/4.1/ref/models/querysets/#std-fieldlookup-startswith), [`istartswith`](https://django.fun/ru/docs/django/4.1/ref/models/querysets/#std-fieldlookup-istartswith), [`endswith`](https://django.fun/ru/docs/django/4.1/ref/models/querysets/#std-fieldlookup-endswith), или [`iendswith`](https://django.fun/ru/docs/django/4.1/ref/models/querysets/#std-fieldlookup-iendswith) при поиске в PostgreSQL не работает для значений без дефисов, потому что PostgreSQL хранит их в типе переноса с типом uuid.